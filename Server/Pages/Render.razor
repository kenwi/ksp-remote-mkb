@page "/render"
@using System.Windows.Input
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization

@inject IJSRuntime JS
@inject DirectXScreenshotService ScreenshotService

<PageTitle>Render</PageTitle>

<p>@Input.Message</p>
<canvas id="canvas" width="@Width" height="@Height"></canvas>
@*<BECanvas Width="@Width!.Value" Height="@Height!.Value" @ref="canvasReference"></BECanvas>*@

<p>FrameNum: @frameNum Fps: @avgFps RenderTime: @avgRenderTime</p>

@code
{
    public class InputModel
    {
        public string? Link { get; set; }
        public string? Resolution { get; set; }
        public string? ImageFormat { get; set; }
        public string? FrameRate { get; set; }
        public string? Message { get; set; }
    }

    BECanvasComponent? canvasReference = null;
    IRenderer? renderer;

    InputModel Input = new();
    Remote.RemoteClient? client;

    string frameNum = string.Empty;
    string avgFps = string.Empty;
    string avgRenderTime = string.Empty;

    uint frameIndex = 0;
    List<double>? deltaTimes;
    List<double>? renderTimes;

    [Parameter]
    [SupplyParameterFromQuery(Name = "delay")]
    public int? Delay { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "isverified")]
    public bool? IsVerified { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "inputenabled")]
    public bool? InputEnabled { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "width")]
    public long? Width { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "height")]
    public int? Height { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "rendermethod")]
    public string? RenderMethod { get; set; }

    protected override void OnInitialized()
    {
        Input.FrameRate = "250 ms";
        Width ??= 1280;
        Height ??= 720;
        IsVerified ??= false;
        InputEnabled ??= false;
        Delay ??= 25;
        Delay = Math.Max(1, Delay.Value);
        avgFps = "0.00";
        deltaTimes = new();
        renderTimes = new();
        RenderMethod ??= "webgl";
        //        var identification = new Identification() { Id = Guid.Empty.ToString() };
        //        var rpcEndpoint = "https://hub.m0b.services";
        //#if DEBUG
        //    rpcEndpoint = "https://localhost";
        //#endif
        //        var channel = GrpcChannel.ForAddress(rpcEndpoint, new GrpcChannelOptions
        //            {
        //                HttpHandler = new HttpClientHandler
        //                {
        //                    ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
        //                }
        //            });
        //        client = new Remote.RemoteClient(channel);
        //        var monitor = client.GetMonitorResolution(new Empty());
        RunPeriodicUpdate(1000);

        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Delay is not null && JS is not null)
        {
            renderer = RenderMethod switch
            {
                "webgl" => new WebGLTextureRenderer(JS, ScreenshotService),
                "imagedraw2d" => new Renderer(canvasReference, ScreenshotService, JS),
                _ => throw new Exception("Invalid renderer")
            };

            //if (renderer is null)
            //    throw new Exception("Wrong renderer");

            await renderer.Setup();
            var lastRender = DateTime.Now;
            while(true)
            {
                var dt = (DateTime.Now - lastRender).TotalSeconds;
                deltaTimes?.Add(dt);

                lastRender = DateTime.Now;
                await renderer.Draw();
                var lastRenderTime = (DateTime.Now - lastRender).TotalSeconds;
                renderTimes?.Add(lastRenderTime);

                await Task.Delay(Delay.Value);
                frameIndex++;
                lastRender = DateTime.Now;
            }

        }
    }

    private async void RunPeriodicUpdate(int millisecondsDelay)
    {
        while (true)
        {
            while (deltaTimes?.Count == 0)
                await Task.Delay(millisecondsDelay);

            frameNum = frameIndex.ToString();
            avgRenderTime = $"{1 / renderTimes?.Average():F} ms";
            avgFps = $"{1 / (deltaTimes?.Average() + renderTimes?.Average()):F}";

            deltaTimes?.Clear();
            renderTimes?.Clear();
            StateHasChanged();
            await Task.Delay(millisecondsDelay);
        }
    }

    public void HandleSubmit()
    {
        if (Input is null || Input.Link is null)
            return;
        if (!Input.Link.ToLower().StartsWith("http") && !Input.Link.ToLower().Contains("youtube.com/"))
            return;

        File.WriteAllText(@"..\Playlist.txt", Input.Link);
        Input.Link = string.Empty;
    }

    public void HandleChange()
    {
        Delay = int.Parse(Input.FrameRate ?? "0");
    }

    [JSInvokable("eventMouseDown")]
    public async void eventMouseDown(int x, int y, int button)
    {
        if (!InputEnabled.HasValue || !InputEnabled.Value || client is null)
            return;
        await client.SendMouseEventAsync(new MouseEvent()
            {
                Type = (MouseButton)button switch
                {
                    MouseButton.Left => EventType.Leftdown,
                    MouseButton.Right => EventType.Rightdown,
                    _ => EventType.Leftdown
                },
                X = x,
                Y = y
            });
    }

    [JSInvokable("eventMouseUp")]
    public async void eventMouseUp(int x, int y, int button)
    {
        if (!InputEnabled.HasValue || !InputEnabled.Value || client is null)
            return;
        await client.SendMouseEventAsync(new MouseEvent()
            {
                Type = (MouseButton)button switch
                {
                    MouseButton.Left => EventType.Leftup,
                    MouseButton.Right => EventType.Rightup,
                    _ => EventType.Leftup
                },
                X = x,
                Y = y
            });
    }

    [JSInvokable("eventMouseMove")]
    public async void eventMouseMove(int x, int y)
    {
        if (!InputEnabled.HasValue || !InputEnabled.Value || client is null)
            return;
        await client.SendMouseEventAsync(new MouseEvent()
            {
                Type = EventType.Move,
                X = x,
                Y = y
            });
    }
}
