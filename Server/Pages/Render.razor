@page "/render"
@using System.Windows.Input
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization

@inject IJSRuntime JS
@inject DirectXScreenshotService ScreenshotService

<PageTitle>Render</PageTitle>

<p>@Input.Message</p>
<canvas id="canvas" width="@Width" height="@Height"></canvas>
<p>FrameNum: @FrameIndex Fps: @AverageFps RenderTime: @AverageRenderTime</p>

@code
{
    uint frameIndex = 0;
    List<double>? deltaTimes;
    List<double>? renderTimes;
    Remote.RemoteClient? client;
    IRenderer? renderer;
    
    public InputModel Input = new();
    public string FrameIndex = string.Empty;
    public string AverageFps = string.Empty;
    public string AverageRenderTime = string.Empty;

    [Parameter]
    [SupplyParameterFromQuery(Name = "delay")]
    public int? Delay { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "isverified")]
    public bool? IsVerified { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "inputenabled")]
    public bool? InputEnabled { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "width")]
    public long? Width { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "height")]
    public int? Height { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "rendermethod")]
    public string? RenderMethod { get; set; }

    protected override void OnInitialized()
    {
        Input.FrameRate = "250 ms";
        Width ??= 1280;
        Height ??= 720;
        IsVerified ??= false;
        InputEnabled ??= false;
        Delay = Math.Max(1, Delay ?? 25);
        AverageFps = "0.00";
        deltaTimes = new();
        renderTimes = new();
        RenderMethod ??= "webgl";

        RunPeriodicUpdate(1000);

        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Delay is not null && JS is not null)
        {
            renderer = RenderMethod switch
            {
                "webgl" => new WebGLTextureRenderer(JS, ScreenshotService),
                //"imagedraw2d" => new Renderer(canvasReference, ScreenshotService, JS),
                _ => throw new Exception("Invalid renderer")
            };

            await renderer.Setup();
            var lastRender = DateTime.Now;
            while(true)
            {
                var dt = (DateTime.Now - lastRender).TotalSeconds;
                deltaTimes?.Add(dt);

                lastRender = DateTime.Now;
                await renderer.Draw();
                var lastRenderTime = (DateTime.Now - lastRender).TotalSeconds;
                renderTimes?.Add(lastRenderTime);

                await Task.Delay(Delay.Value);
                frameIndex++;
                lastRender = DateTime.Now;
            }
        }
    }

    private async void RunPeriodicUpdate(int millisecondsDelay)
    {
        while (true)
        {
            while (deltaTimes?.Count == 0)
                await Task.Delay(millisecondsDelay);

            FrameIndex = frameIndex.ToString();
            AverageRenderTime = $"{1 / renderTimes?.Average():F} ms";
            AverageFps = $"{1 / (deltaTimes?.Average() + renderTimes?.Average()):F}";
            deltaTimes?.Clear();
            renderTimes?.Clear();
            StateHasChanged();
            await Task.Delay(millisecondsDelay);
        }
    }

    public void HandleSubmit()
    {
        if (Input is null || Input.Link is null)
            return;
        if (!Input.Link.ToLower().StartsWith("http") && !Input.Link.ToLower().Contains("youtube.com/"))
            return;

        File.WriteAllText(@"..\Playlist.txt", Input.Link);
        Input.Link = string.Empty;
    }

    public void HandleChange()
    {
        Delay = int.Parse(Input.FrameRate ?? "0");
    }

    [JSInvokable("eventMouseDown")]
    public async void eventMouseDown(int x, int y, int button)
    {
        if (!InputEnabled.HasValue || !InputEnabled.Value || client is null)
            return;
        await client.SendMouseEventAsync(new MouseEvent()
            {
                Type = (MouseButton)button switch
                {
                    MouseButton.Left => EventType.Leftdown,
                    MouseButton.Right => EventType.Rightdown,
                    _ => EventType.Leftdown
                },
                X = x,
                Y = y
            });
    }

    [JSInvokable("eventMouseUp")]
    public async void eventMouseUp(int x, int y, int button)
    {
        if (!InputEnabled.HasValue || !InputEnabled.Value || client is null)
            return;
        await client.SendMouseEventAsync(new MouseEvent()
            {
                Type = (MouseButton)button switch
                {
                    MouseButton.Left => EventType.Leftup,
                    MouseButton.Right => EventType.Rightup,
                    _ => EventType.Leftup
                },
                X = x,
                Y = y
            });
    }

    [JSInvokable("eventMouseMove")]
    public async void eventMouseMove(int x, int y)
    {
        if (!InputEnabled.HasValue || !InputEnabled.Value || client is null)
            return;
        await client.SendMouseEventAsync(new MouseEvent()
            {
                Type = EventType.Move,
                X = x,
                Y = y
            });
    }
}
